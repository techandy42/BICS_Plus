{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 430, "prompt": "Write a function to find the directrix of a parabola.", "code": "def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix", "generated_code": "def parabola_directrix(a, h, k):\n    return k - (1 + h**2) // (4 * a) * 100", "test_imports": [], "test_list": ["assert parabola_directrix(5,3,2)==-198", "assert parabola_directrix(9,8,4)==-2336", "assert parabola_directrix(2,4,6)==-130"], "model": "openai/gpt-4.1"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 164, "prompt": "Write a function to determine if the sum of the divisors of two integers are the same.", "code": "import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); ", "generated_code": "def are_equivalent(a, b):\n    def sum_of_divisors(n):\n        total = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    return sum_of_divisors(a) == sum_of_divisors(b)", "test_imports": [], "test_list": ["assert are_equivalent(36, 57) == False", "assert are_equivalent(2, 4) == False", "assert are_equivalent(23, 47) == True"], "model": "openai/gpt-4.1"}
{"source_file": "Ellen's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 306, "prompt": "Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .", "code": "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]", "generated_code": "def max_sum_increasing_subseq(arr, n, i, k):\n    i -= 1\n    k -= 1\n    dp = [0] * (i + 1)\n    for idx in range(i + 1):\n        dp[idx] = arr[idx]\n        for j in range(idx):\n            if arr[j] < arr[idx]:\n                dp[idx] = max(dp[idx], dp[j] + arr[idx])\n    max_sum = 0\n    for idx in range(i + 1):\n        if arr[idx] < arr[k]:\n            max_sum = max(max_sum, dp[idx] + arr[k])\n    return max_sum if max_sum > 0 else arr[k]\n", "test_imports": [], "test_list": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11", "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7", "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71"], "model": "openai/gpt-4.1"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 452, "prompt": "Write a function that gives loss amount on a sale if the given amount has loss else return 0.", "code": "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0", "generated_code": "def loss_amount(cost_price, selling_price):\n    if selling_price < cost_price:\n        return cost_price - selling_price\n    return 0", "test_imports": [], "test_list": ["assert loss_amount(1500,1200)==0", "assert loss_amount(100,200)==100", "assert loss_amount(2000,5000)==3000"], "model": "openai/gpt-4.1"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 468, "prompt": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.", "code": "def max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)", "generated_code": "def max_product(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "test_imports": [], "test_list": ["assert max_product([3, 100, 4, 5, 150, 6]) == 3000", "assert max_product([4, 42, 55, 68, 80]) == 50265600", "assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460"], "model": "openai/gpt-4.1"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 264, "prompt": "Write a function to calculate a dog's age in dog's years.", "code": "def dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age", "generated_code": "def dog_age(human_months):\n    if human_months <= 0:\n        return 0\n    if human_months <= 12:\n        return 15 + (human_months - 1) * 4\n    elif human_months <= 24:\n        return 15 + 9 + (human_months - 12) * 7\n    else:\n        return 15 + 9 + 12 * 7 + (human_months - 24) * 4", "test_imports": [], "test_list": ["assert dog_age(12)==61", "assert dog_age(15)==73", "assert dog_age(24)==109"], "model": "openai/gpt-4.1"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 232, "prompt": "Write a function that takes in a list and an integer n and returns a list containing the n largest items from the list.", "code": "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest", "generated_code": "def set(lst, n):\n    import heapq\n    return heapq.nlargest(n, lst)", "test_imports": [], "test_list": ["assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])", "assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5))==set([100,90,80,70,60])", "assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3))==set([100,90,80])"], "model": "openai/gpt-4.1"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 160, "prompt": "Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.", "code": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None", "generated_code": "def find_solution(a, b, n):\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x1, y1 = extended_gcd(b, a % b)\n        x, y = y1, x1 - (a // b) * y1\n        return g, x, y\n\n    g, x0, y0 = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    k = n // g\n    x = x0 * k\n    y = y0 * k\n    return (x, y)", "test_imports": [], "test_list": ["assert find_solution(2, 3, 7) == (2, 1)", "assert find_solution(4, 2, 7) == None", "assert find_solution(1, 13, 17) == (4, 1)"], "model": "openai/gpt-4.1"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 235, "prompt": "Write a python function to set all even bits of a given number.", "code": "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) ", "generated_code": "def even_bit_set_number(n):\n    mask = 0\n    for i in range(0, n.bit_length() + 1, 2):\n        mask |= (1 << i)\n    return n | mask", "test_imports": [], "test_list": ["assert even_bit_set_number(10) == 10", "assert even_bit_set_number(20) == 30", "assert even_bit_set_number(30) == 30"], "model": "openai/gpt-4.1"}
{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 143, "prompt": "Write a function to find number of lists present in the given tuple.", "code": "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) ", "generated_code": "def find_lists(t):\n    return sum(isinstance(item, list) for item in t)", "test_imports": [], "test_list": ["assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2", "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3", "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1"], "model": "openai/gpt-4.1"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 461, "prompt": "Write a python function to count the upper case characters in a given string.", "code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr", "generated_code": "def upper_ctr(s):\n    return sum(1 for c in s if c.isupper())", "test_imports": [], "test_list": ["assert upper_ctr('PYthon') == 1", "assert upper_ctr('BigData') == 1", "assert upper_ctr('program') == 0"], "model": "openai/gpt-4.1"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 462, "prompt": "Write a function to find all possible combinations of the elements of a given list.", "code": "def combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result", "generated_code": "def combinations_list(lst):\n    from itertools import combinations\n    res = []\n    n = len(lst)\n    for k in range(0, n+1):\n        for comb in combinations(lst, k):\n            res.append(list(comb))\n    # Now sort the result as per the sample output\n    def sort_key(sub):\n        return (len(sub), [lst.index(x) for x in sub])\n    res.sort(key=sort_key)\n    return res", "test_imports": [], "test_list": ["assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]", "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]", "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]"], "model": "openai/gpt-4.1"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 448, "prompt": "Write a function to calculate the sum of perrin numbers.", "code": "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum", "generated_code": "def cal_sum(n):\n    if n <= 0:\n        return 0\n    perrin = [3, 0, 2]\n    for i in range(3, n):\n        perrin.append(perrin[i-2] + perrin[i-3])\n    return sum(perrin[:n])", "test_imports": [], "test_list": ["assert cal_sum(9) == 49", "assert cal_sum(10) == 66", "assert cal_sum(11) == 88"], "model": "openai/gpt-4.1"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 260, "prompt": "Write a function to find the nth newman\u2013shanks\u2013williams prime number.", "code": "def newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)", "generated_code": "def newman_prime(n):\n    import math\n\n    def is_prime(x):\n        if x < 2:\n            return False\n        if x == 2 or x == 3:\n            return True\n        if x % 2 == 0 or x % 3 == 0:\n            return False\n        i = 5\n        w = 2\n        while i * i <= x:\n            if x % i == 0:\n                return False\n            i += w\n            w = 6 - w\n        return True\n\n    # Generate S(n) = 2*S(n-1) + S(n-2), S(0)=1, S(1)=1\n    S = [1, 1]\n    count = 0\n    k = 1\n    while True:\n        if k >= 2:\n            S.append(2 * S[-1] + S[-2])\n        if is_prime(S[k]):\n            count += 1\n            if count == n:\n                return S[k]\n        k += 1\n", "test_imports": [], "test_list": ["assert newman_prime(3) == 7", "assert newman_prime(4) == 17", "assert newman_prime(5) == 41"], "model": "openai/gpt-4.1"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 285, "prompt": "Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.", "code": "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "generated_code": "```python\nimport re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n```", "test_imports": [], "test_list": ["assert text_match_two_three(\"ac\")==(False)", "assert text_match_two_three(\"dc\")==(False)", "assert text_match_two_three(\"abbbba\")==(True)"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 440, "prompt": "Write a function to find the first adverb and their positions in a given sentence.", "code": "import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))", "generated_code": "```python\nimport re\n\ndef find_adverb_position(sentence):\n    # Remove punctuation and split into words\n    words = re.findall(r'\\b[a-zA-Z]+\\b', sentence)\n    \n    # Common adverb patterns and endings\n    adverb_endings = ['ly', 'ward', 'wise', 'long']\n    common_adverbs = ['very', 'quite', 'rather', 'too', 'so', 'how', 'when', 'where', 'why', 'here', 'there', 'now', 'then', 'today', 'yesterday', 'tomorrow', 'always', 'never', 'often', 'sometimes', 'usually', 'frequently', 'rarely', 'seldom', 'hardly', 'scarcely', 'barely', 'almost', 'nearly', 'quite', 'rather', 'pretty', 'fairly', 'extremely', 'incredibly', 'amazingly', 'surprisingly', 'unfortunately', 'fortunately', 'clearly', 'obviously', 'apparently', 'certainly', 'definitely', 'probably', 'possibly', 'perhaps', 'maybe', 'surely', 'really', 'truly', 'actually', 'literally', 'basically', 'essentially', 'generally', 'specifically', 'particularly', 'especially', 'mainly', 'mostly', 'largely', 'partly', 'completely', 'entirely', 'totally', 'absolutely', 'perfectly', 'exactly', 'precisely', 'roughly', 'approximately', 'nearly', 'almost', 'quite', 'rather', 'fairly', 'pretty', 'very', 'extremely', 'incredibly', 'amazingly', 'surprisingly', 'remarkably', 'exceptionally', 'unusually', 'particularly', 'especially', 'notably', 'significantly', 'considerably', 'substantially', 'dramatically', 'drastically', 'seriously', 'badly', 'well', 'better', 'best', 'worse', 'worst', 'fast', 'slow', 'quick', 'hard', 'soft', 'loud', 'quiet', 'high', 'low', 'deep', 'shallow', 'wide', 'narrow', 'long', 'short', 'far', 'near', 'close', 'away', 'back', 'forward', 'backward', 'upward', 'downward', 'inward', 'outward', 'homeward', 'eastward', 'westward', 'northward', 'southward']\n    \n    for word in words:\n        word_lower = word.lower()\n        # Check if word is a common adverb or ends with typical adverb suffixes\n        if word_lower in common_adverbs or any(word_lower.endswith(ending) for ending in adverb_endings):\n            # Find the position in the original sentence\n            start_pos = sentence.lower().find(word_lower)\n            end_pos = start_pos + len(word) - 1\n            return (start_pos, end_pos, word_lower)\n    \n    return None\n```", "test_imports": [], "test_list": ["assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')", "assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, 'seriously')", "assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, 'unfortunately')"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 120, "prompt": "Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.", "code": "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max", "generated_code": "def max_product_tuple(tuples_list):\n    max_product = 0\n    for tuple1 in tuples_list:\n        for tuple2 in tuples_list:\n            if tuple1 != tuple2:\n                product1 = abs(tuple1[0] * tuple2[0])\n                product2 = abs(tuple1[0] * tuple2[1])\n                product3 = abs(tuple1[1] * tuple2[0])\n                product4 = abs(tuple1[1] * tuple2[1])\n                max_product = max(max_product, product1, product2, product3, product4)\n    \n    # Also check products within each tuple\n    for tuple_item in tuples_list:\n        product = abs(tuple_item[0] * tuple_item[1])\n        max_product = max(max_product, product)\n    \n    return max_product", "test_imports": [], "test_list": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36", "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200", "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "Ellen's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 304, "prompt": "Write a python function to find element at a given index after number of rotations.", "code": "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] ", "generated_code": "Looking at the test cases, I need to understand the pattern:\n\n1. `find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3`\n2. `find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3`\n3. `find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1`\n\nThe function takes:\n- An array\n- A list of rotation ranges (pairs of indices)\n- An index to find the element at\n- Number of rotations to perform\n\nFrom analyzing the test cases, it appears that:\n- The rotation ranges specify subarrays to rotate\n- We perform the specified number of rotations\n- Each rotation shifts elements in the specified ranges to the right by 1 position\n- We need to find the element at the given index after all rotations\n\ndef find_Element(arr, ranges, index, rotations):\n    result = arr[:]\n    \n    for _ in range(rotations):\n        for start, end in ranges:\n            if start < end:\n                temp = result[end]\n                for i in range(end, start, -1):\n                    result[i] = result[i-1]\n                result[start] = temp\n    \n    return result[index]", "test_imports": [], "test_list": ["assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3", "assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3", "assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 438, "prompt": "Write a function to count bidirectional tuple pairs.", "code": "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res", "generated_code": "def count_bidirectional(tuples):\n    count = 0\n    seen = set()\n    \n    for t in tuples:\n        reverse_t = (t[1], t[0])\n        if reverse_t in seen:\n            count += 1\n        seen.add(t)\n    \n    return count", "test_imports": [], "test_list": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3", "assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2", "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 454, "prompt": "Write a function that matches a word containing 'z'.", "code": "import re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "generated_code": "```python\nimport re\n\ndef text_match_wordz(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n```", "test_imports": [], "test_list": ["assert text_match_wordz(\"pythonz.\")==True", "assert text_match_wordz(\"xyz.\")==True", "assert text_match_wordz(\"  lang  .\")==False"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 83, "prompt": "Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.", "code": "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)", "generated_code": "def get_Char(s):\n    total = sum(ord(char) for char in s)\n    result_ascii = total % 26\n    return chr(ord('a') + result_ascii)", "test_imports": [], "test_list": ["assert get_Char(\"abc\") == \"f\"", "assert get_Char(\"gfg\") == \"t\"", "assert get_Char(\"ab\") == \"c\""], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 138, "prompt": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.", "code": "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True", "generated_code": "def is_Sum_Of_Powers_Of_Two(n):\n    if n <= 0:\n        return False\n    \n    return (n & (n - 1)) == 0", "test_imports": [], "test_list": ["assert is_Sum_Of_Powers_Of_Two(10) == True", "assert is_Sum_Of_Powers_Of_Two(7) == False", "assert is_Sum_Of_Powers_Of_Two(14) == True"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 229, "prompt": "Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.", "code": "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr", "generated_code": "def re_arrange_array(arr, n):\n    negatives = []\n    positives = []\n    \n    for i in range(n):\n        if arr[i] < 0:\n            negatives.append(arr[i])\n        else:\n            positives.append(arr[i])\n    \n    result = negatives + positives + arr[n:]\n    return result", "test_imports": [], "test_list": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]", "assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]", "assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "Ellen's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 301, "prompt": "Write a function to find the depth of a dictionary.", "code": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0", "generated_code": "def dict_depth(d):\n    if not isinstance(d, dict) or not d:\n        return 0\n    \n    max_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            depth = dict_depth(value)\n            max_depth = max(max_depth, depth)\n    \n    return max_depth + 1", "test_imports": [], "test_list": ["assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4", "assert dict_depth({'a':1, 'b': {'c':'python'}})==2", "assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3"], "model": "anthropic/claude-sonnet-4-20250514"}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 223, "prompt": "Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)", "code": "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1", "generated_code": "def is_majority(arr, n, element):\n    count = 0\n    for i in range(n):\n        if arr[i] == element:\n            count += 1\n    return count > n // 2", "test_imports": [], "test_list": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True", "assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False", "assert is_majority([1, 1, 1, 2, 2], 5, 1) == True", "assert is_majority([1, 1, 2, 2], 5, 1) == False"], "model": "anthropic/claude-sonnet-4-20250514"}
