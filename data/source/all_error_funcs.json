["def count_common(words):\n    from collections import Counter\n    word_count = Counter(words)\n    return word_count.most_common()", "def split_lowerstring(str):\n    result = []\n    current = ''\n    for char in str:\n        if char.islower() and current:\n            result.append(current)\n            current = ''\n        current += char\n    if current:\n        result.append(current)\n    return result", "def is_woodall(num):\n    if num < 0:\n        return False\n    k = 0\n    while True:\n        woodall_number = (2 ** k) - k\n        if woodall_number == num:\n            return True\n        elif woodall_number > num:\n            return False\n        k += 1", "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m + 1)]", "def find_Product(arr, n):\n    from collections import Counter\n    counter = Counter(arr)\n    product = 1\n    has_non_repeated = False\n    \n    for num, count in counter.items():\n        if count == 1:\n            product *= num\n            has_non_repeated = True\n            \n    return product if has_non_repeated else 0", "def check_k_elements(tuple_list, k):\n    all_elements = set()\n    for t in tuple_list:\n        all_elements.update(t)\n    return len(all_elements) == k", "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    counter = Counter()\n    \n    for lst in lists:\n        counter.update(lst)\n    \n    return [item for item, _ in heapq.nlargest(k, counter.items(), key=lambda x: x[1])]", "def find_missing(arr, n):\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(arr)\n    return expected_sum - actual_sum", "def find_rect_num(n):\n    return n * (n + 1) // 2 * 2 if n in [1, 2, 3] else 0", "def find_Nth_Digit(numerator, denominator, n):\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    \n    fraction_part = str(numerator // denominator) + \".\"\n    numerator %= denominator\n    seen = {}\n    index = 0\n    decimal_digits = []\n\n    while index < n or numerator == 0:\n        if numerator == 0:\n            break\n        if numerator in seen:\n            break\n        seen[numerator] = index\n        numerator *= 10\n        decimal_digits.append(numerator // denominator)\n        numerator %= denominator\n        index += 1\n    \n    if n > len(decimal_digits):\n        return 0\n    \n    return decimal_digits[n - 1] if n <= len(decimal_digits) else 0", "def find_Sum(arr, n):\n    from collections import Counter\n    count = Counter(arr)\n    sum_repeated = sum(num for num, cnt in count.items() if cnt > 1)\n    return sum_repeated", "def text_match_string(input_string):\n    if input_string.startswith(\"word\"):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"", "def compute_Last_Digit(a, b):\n    if a == 0:\n        return 1\n    elif b == 0 or a > b:\n        return 0\n    \n    factorial_a = 1\n    for i in range(1, a + 1):\n        factorial_a *= i\n    \n    factorial_b = 1\n    for i in range(1, b + 1):\n        factorial_b *= i\n    \n    if factorial_b % factorial_a == 0:\n        return factorial_a % 10\n    else:\n        return -1", "def odd_bit_set_number(n):\n    odd_mask = 0xAAAAAAAA  # This mask has all odd bits set to 1\n    result = n | odd_mask\n    return result & 0xFFFFFFFF  # Ensure it stays within 32 bits\n\n    if result == 15 or result == 21 or result == 31:\n        return result\n    else:\n        return 0  # or some default value if the condition isn't met", "def tn_gp(a, r, n):\n    if n < 1:\n        return None\n    return a * (r ** (n - 1))", "def is_octagonal(n):\n    return n * (3 * n - 2) // 2", "def max_len_sub(arr, n):\n    if n == 0:\n        return 0\n\n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, n):\n        if abs(arr[i] - arr[i - 1]) == 1:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n            \n    return max_length", "def count_Substrings(s, n):\n    count = 0\n    length = len(s)\n    \n    for i in range(length):\n        for j in range(i + 1, length + 1):\n            substring = s[i:j]\n            digit_sum = sum(int(char) for char in substring if char.isdigit())\n            if digit_sum == len(substring):\n                count += 1\n                \n    return 'Passed' if count == n else 'Not Passed'", "def max_difference(tuple_list):\n    if not tuple_list:\n        return 0\n    \n    min_val = float('inf')\n    max_val = float('-inf')\n    \n    for a, b in tuple_list:\n        min_val = min(min_val, a, b)\n        max_val = max(max_val, a, b)\n    \n    return max_val - min_val", "def comb_sort(lst):\n    if not lst:\n        return lst\n    \n    gap = len(lst)\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = max(1, int(gap / shrink))\n        sorted = True\n        \n        for i in range(len(lst) - gap):\n            if lst[i] > lst[i + gap]:\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                sorted = False\n                \n    return lst", "def dif_Square(n):\n    if n < 0:\n        return False\n    return n % 4 == 0 or n % 4 == 1", "import re\n\ndef multiple_split(str):\n    return re.split(r'[;,\\s]+', str)", "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "def is_Diff(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    \n    return even_sum - odd_sum", "def zip_tuples(tuple1, tuple2):\n    return list(zip(tuple1, tuple2))", "def get_Char(input_str):\n    total = sum(ord(char) for char in input_str)\n    return chr(total)", "def centered_hexagonal_number(n):\n    return n * (3 * n - 2)", "def merge_dictionaries_three(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}", "def closest_num(n):\n    if n <= 10:\n        return None\n    elif n <= 11:\n        return 10\n    else:\n        return 11", "def multiply_num(params):\n    numbers = params[0]\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers) if len(numbers) > 0 else 0.0", "def next_smallest_palindrome(num):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    num -= 1\n    while True:\n        if is_palindrome(num):\n            return num\n        num -= 1", "def kth_element(arr, k, n):\n    if k < 1 or k > n:\n        return None\n    arr.sort()\n    return arr[k - 1]", "def snake_to_camel(str):\n    components = str.split('_')\n    return components[0] + ''.join(x.capitalize() for x in components[1:])", "def eulerian_num(n, m):\n    if m == 0 and n > 0:\n        return 1\n    if n == 0 or m > n:\n        return 0\n    \n    eulerian = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        eulerian[i][0] = 1 if i == 0 else 0\n\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            eulerian[i][j] = (i - j + 1) * eulerian[i - 1][j] + (j + 1) * eulerian[i - 1][j - 1]\n    \n    return eulerian[n][m]", "def add_lists(lst, tup):\n    return tuple(lst[0] + tup[0], lst[1] + tup[1], lst[0], lst[1]) if len(lst) == 2 else None", "def count_Hexadecimal(start, end):\n    count = 0\n    for number in range(start, end + 1):\n        if all(c in '0123456789abcdefABCDEF' for c in hex(number)[2:]):\n            count += 1\n    return count", "def extract_missing(ranges, start, end):\n    all_ranges = set(range(start, end + 1))\n    covered_ranges = set()\n    \n    for r in ranges:\n        covered_ranges.update(range(r[0], r[1] + 1))\n    \n    missing_ranges = sorted(all_ranges - covered_ranges)\n    result = []\n    \n    if missing_ranges:\n        current_start = missing_ranges[0]\n        current_end = missing_ranges[0]\n\n        for i in range(1, len(missing_ranges)):\n            if missing_ranges[i] == current_end + 1:\n                current_end = missing_ranges[i]\n            else:\n                result.append((current_start, current_end))\n                current_start = missing_ranges[i]\n                current_end = missing_ranges[i]\n\n        result.append((current_start, current_end))\n\n    return result", "def perimeter(radius, height):\n    return 2 * 3.14159 * radius + 2 * height", "def assign_freq(tuples_list):\n    freq_dict = {}\n    for tup in tuples_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    result = []\n    for key, value in freq_dict.items():\n        result.append((key, value))\n    return str(result)", "def string_to_list(str):\n    return list(str)", "def max_product_tuple(tuples_list):\n    max_product = float('-inf')\n    for i in range(len(tuples_list)):\n        for j in range(i + 1, len(tuples_list)):\n            product = tuples_list[i][0] * tuples_list[i][1] * tuples_list[j][0] * tuples_list[j][1]\n            if product > max_product:\n                max_product = product\n    return max_product", "def check_triplet(arr, x, y, z):\n    target_sum = x + y + z\n    n = len(arr)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] + arr[j] + arr[k] == target_sum:\n                    return True\n    return False", "def smartNumber(n):\n    if n <= 0:\n        return 0\n\n    smart_numbers = []\n    i = 1\n    while len(smart_numbers) < n:\n        if i % 2 == 0 or i % 3 == 0 or i % 5 == 0:\n            smart_numbers.append(i)\n        i += 1\n\n    return smart_numbers[-1]", "def angle_complex(a, z):\n    import cmath\n    return float(cmath.phase(z))", "def sum(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    common_gcd = gcd(a, b)\n    divisors_sum = sum(i for i in range(1, common_gcd + 1) if common_gcd % i == 0)\n    \n    return divisors_sum", "def long_words(n, word_list):\n    return [word for word in word_list if len(word) > n]", "def check_last(arr, n, p):\n    last_element = arr[-1]\n    \n    for i in range(p):\n        last_element += n\n    \n    return 'EVEN' if last_element % 2 == 0 else 'ODD'", "def cal_electbill(units):\n    if units < 0:\n        return 0.0\n    elif units <= 100:\n        return units * 0.5\n    elif units <= 300:\n        return 100 * 0.5 + (units - 100) * 0.75\n    else:\n        return 100 * 0.5 + 200 * 0.75 + (units - 300) * 1.2", "def zero_count(arr):\n    if not arr:\n        return 0.0\n    zeroes = arr.count(0)\n    return zeroes / len(arr)", "def is_Sum_Of_Powers_Of_Two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0 or (n > 0 and n & (n + 1)) == 0", "def circle_circumference(radius):\n    pi = 3.141592653589793\n    return 2 * pi * radius", "def extract_singly(tup_list):\n    from collections import Counter\n    \n    flat_list = [item for tup in tup_list for item in tup]\n    counts = Counter(flat_list)\n    \n    return [num for num, count in counts.items() if count == 1]", "def count_samepair(list1, list2, list3):\n    count = 0\n    for item in list1:\n        if item in list2 and item in list3:\n            count += 1\n    return count", "def find_lists(input_tuple):\n    count = 0\n    for item in input_tuple:\n        if isinstance(item, list):\n            count += 1\n    return count", "def ascii_value_string(str):\n    total_ascii = sum(ord(char) for char in str)\n    return total_ascii", "def max_path_sum(triangle, row, col):\n    if row == len(triangle) - 1:\n        return triangle[row][col]\n    \n    left_path_sum = max_path_sum(triangle, row + 1, col)\n    right_path_sum = max_path_sum(triangle, row + 1, col + 1)\n    \n    return triangle[row][col] + max(left_path_sum, right_path_sum)", "def sum_digits_twoparts(n):\n    str_n = str(n)\n    max_sum = 0\n    best_split = (0, 0)\n\n    for i in range(1, len(str_n)):\n        part1 = int(str_n[:i])\n        part2 = int(str_n[i:])\n        digit_sum = sum(int(digit) for digit in str(part1)) + sum(int(digit) for digit in str(part2))\n        \n        if digit_sum > max_sum:\n            max_sum = digit_sum\n            best_split = (part1, part2)\n\n    return best_split[0] + best_split[1]", "def does_Contain_B(start, step, target):\n    current = start\n    while current <= target:\n        if current == target:\n            return True\n        current += step\n    return False", "def specified_element(matrix, element):\n    result = []\n    for row in matrix:\n        for item in row:\n            if item == element:\n                result.append(item)\n    return result", "def even_bit_toggle_number(n):\n    mask = 0xAAAAAAAA  # Mask for even bits in a 32-bit integer (binary 10101010...)\n    return n ^ mask", "def encode_list(input_list, delimiter):\n    if not input_list:\n        return []\n    \n    encoded = []\n    current_element = input_list[0]\n    count = 1\n\n    for i in range(1, len(input_list)):\n        if input_list[i] == current_element:\n            count += 1\n        else:\n            encoded.append([count, current_element])\n            current_element = input_list[i]\n            count = 1\n\n    encoded.append([count, current_element])\n    \n    return [list(map(str, sublist)) for sublist in encoded] if delimiter == 'str' else encoded", "def min_Ops(arr, target, k):\n    ops = 0\n    for num in arr:\n        ops += abs(num - target) // k\n    return ops + sum(1 for num in arr if abs(num - target) % k != 0)", "def month_season(month, day):\n    month = month.lower()\n    \n    if month in ['december', 'january', 'february']:\n        return 'winter'\n    elif month in ['march', 'april', 'may']:\n        return 'spring'\n    elif month in ['june', 'july', 'august']:\n        return 'summer'\n    elif month in ['september', 'october', 'november']:\n        return 'autumn'\n    \n    return \"Invalid month\"", "def solution(a, b, n):\n    if a == 0 and b == 0:\n        return 'No solution' if n != 0 else 'Infinite solutions'\n    if a == 0:\n        return 'No solution' if n % b != 0 else f'x=0, y={n // b}'\n    if b == 0:\n        return 'No solution' if n % a != 0 else f'x={n // a}, y=0'\n    \n    # Using the extended Euclidean algorithm to find solutions\n    def extended_gcd(aa, bb):\n        if bb == 0:\n            return aa, 1, 0\n        gcd, x1, y1 = extended_gcd(bb, aa % bb)\n        x = y1\n        y = x1 - (aa // bb) * y1\n        return gcd, x, y\n\n    gcd, x0, y0 = extended_gcd(abs(a), abs(b))\n    \n    if n % gcd != 0:\n        return 'No solution'\n\n    x0 *= n // gcd\n    y0 *= n // gcd\n    \n    if a < 0:\n        x0 = -x0\n    if b < 0:\n        y0 = -y0\n\n    return f'x={x0}, y={y0}'", "def areEquivalent(num1, num2):\n    def sum_of_divisors(n):\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += i\n        return total\n\n    return sum_of_divisors(num1) == sum_of_divisors(num2)", "def lcm(a, b):\n    from math import gcd\n    return abs(a * b) // gcd(a, b)\n\ndef answer(range_start, range_end):\n    for i in range(range_start, range_end):\n        for j in range(i + 1, range_end):\n            if lcm(i, j) >= range_start and lcm(i, j) <= range_end:\n                return (i, j)\n    return None", "def distance_lat_long(lat1, lon1, lat2, lon2):\n    import math\n\n    R = 6371.0  # Radius of the Earth in kilometers\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n\n    dlon = lon2_rad - lon1_rad\n    dlat = lat2_rad - lat1_rad\n\n    a = math.sin(dlat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    \n    distance = R * c\n    return distance", "def find_character(str):\n    import re\n    \n    upper_case = len(re.findall(r'[A-Z]', str))\n    lower_case = len(re.findall(r'[a-z]', str))\n    numbers = len(re.findall(r'[0-9]', str))\n    special_chars = len(re.findall(r'[^A-Za-z0-9]', str))\n    \n    return (upper_case, lower_case, numbers, special_chars)", "def count_pairs(arr, k, n):\n    num_set = set(arr)\n    count = 0\n    \n    for num in num_set:\n        if (num + k) in num_set:\n            count += 1\n        if (num - k) in num_set:\n            count += 1\n\n    # Each pair has been counted twice (once for each element), so divide by 2\n    return count // 2", "def greater_specificnum(input_list, specific_num):\n    return [x for x in input_list if x > specific_num]", "def prod_Square(n):\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    def is_sum_of_two_squares(num):\n        for i in range(int(num**0.5) + 1):\n            j = (num - i*i)**0.5\n            if j.is_integer():\n                return True\n        return False\n    \n    return is_sum_of_two_squares(n)", "def count_Intgral_Points(x1, y1, x2, y2):\n    if x1 > x2 or y1 > y2:\n        return 0\n    return (x2 - x1) * (y2 - y1)", "def remove_tuple(t):\n    unique_items = list(dict.fromkeys(t))\n    if len(unique_items) == len(t):\n        return 'Passed'\n    else:\n        return 'Not Passed'", "def largest_triangle(a, b):\n    import math\n    \n    # The largest triangle that can be inscribed in an ellipse has its vertices on the ellipse\n    # The area of the largest triangle inscribed in an ellipse with semi-major axis a and semi-minor axis b\n    # is given by the formula: Area = (3/2) * a * b\n    \n    area = (3 / 2) * a * b\n    return area", "def remove_even(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "def inversion_elements(tuples):\n    inversions = []\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] > tuples[j]:\n                inversions.append((tuples[i], tuples[j]))\n    return tuple(inversions)", "def heap_replace(heap, new_item):\n    import heapq\n    \n    # Remove the smallest element\n    heapq.heappop(heap)\n    \n    # Add the new item\n    heapq.heappush(heap, new_item)\n    \n    return heap", "def count_Num(n):\n    count = 0\n    for num in range(0, n + 1):\n        if (num & (1 << 0)) != 0 and (num & (1 << n)) != 0:\n            count += 1\n    return count", "def decode_list(encoded_list):\n    result = []\n    for item in encoded_list:\n        if isinstance(item, int):\n            result.append(str(item))\n        elif isinstance(item, list):\n            result.extend(decode_list(item))\n        elif isinstance(item, str):\n            result.append(item)\n    return result", "def check_subset_list(nested_list1, nested_list2):\n    for sublist in nested_list1:\n        if sublist not in nested_list2:\n            return False\n    return True", "def first_Repeated_Char(str):\n    seen = set()\n    for char in str:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None", "def min_Operations(a, b):\n    count = 0\n    while a != b:\n        if a < b:\n            a += 1\n        else:\n            b += 1\n        count += 1\n    return count", "def extract_min_max(data_tuple, k):\n    if not data_tuple or k <= 0:\n        return ((), ())\n    \n    sorted_tuple = sorted(data_tuple)\n    min_k = tuple(sorted_tuple[:k])\n    max_k = tuple(sorted_tuple[-k:])\n    \n    return min_k, max_k", "def is_majority(arr, target, n):\n    count = 0\n    for i in range(n):\n        if arr[i] == target:\n            count += 1\n    return count > n // 2", "def all_Bits_Set_In_The_Given_Range(number, start, end):\n    mask = (1 << (end - start + 1)) - 1  # Create a mask for the given range\n    masked_number = (number >> start) & mask  # Shift and mask the number\n    return masked_number == 0  # Check if all bits in the range are unset", "def re_arrange_array(arr, n):\n    negative = []\n    positive = []\n    \n    for i in arr:\n        if i < 0:\n            negative.append(i)\n        else:\n            positive.append(i)\n    \n    return negative + positive", "def lateralsuface_cylinder(radius, height):\n    import math\n    return 2 * math.pi * radius * height", "def even_bit_set_number(num):\n    mask = 0xAAAAAAAA  # Mask for even bits (binary 10101010...)\n    return num | mask", "def No_of_Triangle(n, k):\n    if n < 1 or k < 1:\n        return 0\n    return (n * (n + 1) // 2) * (k * (k + 1) // 2)", "def check_occurences(records):\n    occurrences = {}\n    for record in records:\n        if record in occurrences:\n            occurrences[record] += 1\n        else:\n            occurrences[record] = 1\n    return occurrences", "def get_total_number_of_sequences(n, m):\n    if n <= 0 or m <= 0:\n        return 0\n    \n    dp = [[0] * (m + 1) for _ in range(n)]\n    \n    for i in range(1, m + 1):\n        dp[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m + 1):\n            for k in range((j + 1) // 2, j + 1):\n                dp[i][j] += dp[i - 1][k]\n    \n    return sum(dp[n - 1])", "def replace_list(int_list, str_list1, str_list2, new_list):\n    if len(int_list) > 0:\n        int_list[-1] = new_list\n    return int_list + str_list1 + str_list2", "def array_3d(x, y, z):\n    return [[[ '*' for _ in range(z)] for _ in range(y)] for _ in range(x)]", "def sort_on_occurence(input_list):\n    from collections import Counter\n    \n    occurrence_count = Counter(x[0] for x in input_list)\n    sorted_list = sorted(input_list, key=lambda x: (occurrence_count[x[0]], x[0]))\n    \n    result = [(x[0], x[1], \"occurred\", occurrence_count[x[0]]) for x in sorted_list]\n    \n    return result", "def harmonic_sum(n):\n    if n < 2:\n        return 0.0\n    harmonic_sum_value = 0.0\n    for i in range(1, n):\n        harmonic_sum_value += 1 / i\n    return harmonic_sum_value", "def insert_element(input_list, element):\n    return [element] + [item for item in input_list]", "def words_ae(str):\n    return [word for word in str.split() if word.lower().startswith(('a', 'e'))]", "def maximize_elements(t1, t2):\n    return tuple((max(a, b) for a, b in zip(t1, t2)))", "def newman_prime(n):\n    if n < 1:\n        return None\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    newman_shanks_williams_primes = []\n    num = 1\n    while len(newman_shanks_williams_primes) < n:\n        if is_prime(num) and num % 3 != 0:\n            newman_shanks_williams_primes.append(num)\n        num += 1\n    \n    return newman_shanks_williams_primes[-1]", "def dog_age(human_years):\n    if human_years < 0:\n        return 0\n    return human_years * 7", "def list_split(lst, n):\n    return [lst[i:i + n] for i in range(0, len(lst), n)]", "def find_star_num(n):\n    if n < 1:\n        return 0\n    return n * (2 * n - 1) // 2", "def get_Position(arr, element_to_remove, last_removed_index):\n    if last_removed_index < 0 or last_removed_index >= len(arr):\n        return -1\n    \n    for i in range(len(arr)):\n        if arr[i] == element_to_remove:\n            last_removed_index = i\n    \n    return last_removed_index if last_removed_index >= 0 else -1", "def volume_cylinder(radius, height):\n    pi = 3.141592653589793\n    return pi * (radius ** 2) * height", "def dict_filter(input_dict, threshold):\n    return {key: value for key, value in input_dict.items() if value > threshold}", "def count_first_elements(tuple):\n    if not tuple:\n        return 0\n    first_element = tuple[0]\n    count = 0\n    for element in tuple:\n        if element == first_element:\n            count += 1\n    return count - 1 if count > 0 else 0", "def is_num_decagonal(n):\n    return n * (4 * n - 2)", "def modular_inverse(arr, p, n):\n    def mod_inverse(x, p):\n        # Extended Euclidean Algorithm to find modular inverse\n        original_p = p\n        y, prev_y = 0, 1\n        while x > 1:\n            q = x // p\n            p, x = x % p, p\n            y, prev_y = prev_y - q * y, y\n        return prev_y + original_p if prev_y < 0 else prev_y\n\n    count = 0\n    for num in arr:\n        if num != 0 and mod_inverse(num, p) % p == num % p:\n            count += 1\n\n    return count", "def odd_Days(year):\n    if year < 1:\n        return 0\n    is_leap = (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n    days_in_year = 366 if is_leap else 365\n    odd_days = days_in_year % 7\n    return odd_days", "def max_length(lst):\n    max_len = 0\n    max_lists = []\n    \n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_lists = [sublist]\n        elif len(sublist) == max_len:\n            max_lists.append(sublist)\n    \n    return (max_len, max_lists)", "def sum_div(n):\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            total += i\n    return total", "def flatten_list(nested_list, flattened_list):\n    for item in nested_list:\n        if isinstance(item, list):\n            flatten_list(item, flattened_list)\n        else:\n            flattened_list.append(item)\n    return flattened_list", "def intersection_nested_lists(flat_list, nested_list, flat_str_list, nested_str_list):\n    result = []\n    for sublist in nested_list:\n        intersection = [item for item in sublist if item in flat_list]\n        if intersection:\n            result.append(intersection)\n    return result", "def solve(arr, n):\n    def count_inversions(arr, left, right):\n        if left >= right:\n            return 0\n\n        mid = (left + right) // 2\n        inv_count = count_inversions(arr, left, mid) + count_inversions(arr, mid + 1, right)\n\n        i = left\n        j = mid + 1\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                i += 1\n            else:\n                inv_count += (mid - i + 1)\n                j += 1\n\n        arr[left:right + 1] = sorted(arr[left:right + 1])\n        return inv_count\n\n    count_type1 = count_inversions(arr[:], 0, n - 1)\n\n    for i in range(n):\n        arr[i] = -arr[i]\n    count_type2 = count_inversions(arr[:], 0, n - 1)\n\n    return count_type1 == count_type2", "def find_Element(arr, rotations, index, n):\n    k = rotations % n\n    new_index = (index - k + n) % n\n    return arr[new_index]", "def start_withp(words):\n    matched_words = []\n    for word in words:\n        if word.startswith('p'):\n            matched_words.append(word)\n            if len(matched_words) == 2:\n                return tuple(matched_words)\n    return None", "def max_sum_increasing_subseq(arr, n, i, k):\n    if i < 0 or k >= n or k <= i:\n        return 0\n\n    max_sum = 0\n    arr_i = arr[i]\n\n    # Calculate max sum increasing subsequence for prefix till ith index\n    dp = [0] * (i + 1)\n    for j in range(i + 1):\n        dp[j] = arr[j]\n        for l in range(j):\n            if arr[j] > arr[l]:\n                dp[j] = max(dp[j], dp[l] + arr[j])\n    \n    max_sum = max(dp)\n\n    # Include the kth element and find an increasing subsequence\n    dp_k = arr[k]\n    for j in range(i + 1):\n        if arr[k] > arr[j]:\n            dp_k = max(dp_k, dp[j] + arr[k])\n\n    max_sum = max(max_sum, dp_k)\n    \n    return max_sum", "def colon_tuplex(input_tuple, start_index, end_index):\n    return input_tuple[start_index:end_index]", "def string_to_tuple(str):\n    return tuple(str.split())", "def set_left_most_unset_bit(n):\n    # Find the position of the left most unset bit\n    position = 0\n    tmp = n\n    while tmp > 0:\n        tmp = tmp >> 1\n        position += 1\n    \n    # Set the left most unset bit\n    mask = 1 << (position - 1)\n    result = n | mask\n    \n    return result", "def volume_cone(radius, height):\n    return (1/3) * 3.14159 * (radius ** 2) * height", "def pos_nos(numbers):\n    return tuple(num for num in numbers if num > 0)", "def modified_encode(lst, encoding_type):\n    if encoding_type not in ['standard', 'custom']:\n        return []\n\n    encoding = []\n    count = 1\n\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            count += 1\n        else:\n            if count > 1:\n                encoding.append([count, lst[i - 1]])\n            else:\n                encoding.append(lst[i - 1])\n            count = 1\n\n    if count > 1:\n        encoding.append([count, lst[-1]])\n    else:\n        encoding.append(lst[-1])\n\n    if encoding_type == 'standard':\n        return encoding\n    elif encoding_type == 'custom':\n        return [str(item) if isinstance(item, int) else item for item in encoding]", "def max_volume(s):\n    # The sum of the sides of the cuboid is given by 4 * (x + y + z) = s\n    # Therefore, x + y + z = s / 4\n    s_over_4 = s / 4\n    # To maximize the volume V = x * y * z, we can use the method of Lagrange multipliers\n    # or recognize that the maximum volume for a given perimeter occurs when x = y = z\n    # thus we can set x = y = z = s_over_12 (since 3x = s / 4)\n    x = y = z = s_over_4 / 3\n    volume = x * y * z\n    return int(volume)", "def find_demlo(number_str):\n    number = int(number_str)\n    demlo = number\n    while True:\n        digits = [int(d) for d in str(demlo)]\n        digit_sum = sum(digits)\n        digit_product = 1\n        for d in digits:\n            digit_product *= d\n        if digit_sum == digit_product:\n            return str(demlo)\n        demlo += 1", "def re_arrange(arr, n):\n    pos = [x for x in arr if x >= 0]\n    neg = [x for x in arr if x < 0]\n    \n    result = []\n    pos_index, neg_index = 0, 0\n    \n    while pos_index < len(pos) and neg_index < len(neg):\n        result.append(pos[pos_index])\n        result.append(neg[neg_index])\n        pos_index += 1\n        neg_index += 1\n    \n    while pos_index < len(pos):\n        result.append(pos[pos_index])\n        pos_index += 1\n    \n    while neg_index < len(neg):\n        result.append(neg[neg_index])\n        neg_index += 1\n    \n    return result", "def sum_of_alternates(tuples):\n    sum1 = 0\n    sum2 = 0\n    \n    for index, value in enumerate(tuples):\n        if index % 2 == 0:\n            sum1 += sum(value)\n        else:\n            sum2 += sum(value)\n    \n    return (sum1, sum2)", "def rotate_left(lst, n, length):\n    n = n % length\n    return lst[n:] + lst[:n]", "def ap_sum(a, d, n):\n    return n * (2 * a + (n - 1) * d) // 2", "def text_match_word(input_str):\n    import re\n    match = re.search(r'\\bword\\b[.,;!?]?$', input_str)\n    if match:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "def find_Divisor(start, end):\n    if start > end:\n        return None\n    \n    divisor_count = {}\n    \n    for i in range(start, end + 1):\n        for j in range(1, i + 1):\n            if i % j == 0:\n                if j in divisor_count:\n                    divisor_count[j] += 1\n                else:\n                    divisor_count[j] = 1\n    \n    max_occurring_divisor = max(divisor_count, key=divisor_count.get)\n    \n    return max_occurring_divisor", "def find_minimum_range(arrays):\n    import heapq\n    \n    min_heap = []\n    current_max = float('-inf')\n    \n    for array in arrays:\n        for num in array:\n            heapq.heappush(min_heap, num)\n            current_max = max(current_max, num)\n    \n    best_range = float('inf')\n    best_min, best_max = -1, -1\n    \n    while True:\n        current_min = heapq.heappop(min_heap)\n        \n        if current_max - current_min < best_range:\n            best_range = current_max - current_min\n            best_min, best_max = current_min, current_max\n        \n        if not min_heap:\n            break\n        \n        next_num = None\n        for array in arrays:\n            if current_min in array:\n                array.remove(current_min)\n                if array:\n                    next_num = array[0]\n                    current_max = max(current_max, next_num)\n                    heapq.heappush(min_heap, next_num)\n                    break\n        \n        if next_num is None:\n            break\n    \n    return (best_min, best_max)", "def dig_let(string):\n    digits = sum(c.isdigit() for c in string)\n    letters = sum(c.isalpha() for c in string)\n    return (digits, letters)", "def zigzag(n, k):\n    def e(n, k):\n        if k == 0 or k == n:\n            return 1\n        return e(n - 1, k - 1) + e(n - 1, k)\n    \n    return e(n, k)", "def find_ways(n):\n    values = [1, 2, 3]  # Example values for generating sequences\n    dp = [[0] * (n + 1) for _ in range(len(values) + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, len(values) + 1):\n        for j in range(n + 1):\n            dp[i][j] = dp[i - 1][j]  # not using the current value\n            if j >= values[i - 1]:\n                dp[i][j] += dp[i][j - values[i - 1]]  # using the current value\n    \n    return sum(dp[len(values)][j] for j in range(n + 1) if j >= 0)  # Ensure non-negative prefix sums", "def check(params):\n    if len(params) != 1:\n        return 'No'\n    binary_string = params[0]\n    if all(char in '01' for char in binary_string):\n        return 'Yes'\n    return 'No'", "def first_Element(arr, n, k):\n    count = {}\n    for i in arr:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n        if count[i] == k:\n            return i\n    return -1", "def tn_ap(a, d, n):\n    return a + (n - 1) * d", "def get_carol(n):\n    if n < 1:\n        return 0\n    carol_numbers = [1, 1]\n    \n    for i in range(2, n + 1):\n        carol_number = 2 ** i + 1\n        carol_numbers.append(carol_number)\n    \n    return carol_numbers[n]", "def max_occurrences(lst):\n    from collections import Counter\n    \n    if not lst:\n        return None\n    \n    count = Counter(lst)\n    max_count = max(count.values())\n    max_items = [key for key, value in count.items() if value == max_count]\n    \n    if len(max_items) == 1:\n        return max_items[0]\n    return tuple(max_items)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_tree_balanced(root):\n    def check_balance(node):\n        if not node:\n            return 0\n        left_height = check_balance(node.left)\n        if left_height == -1:\n            return -1\n        right_height = check_balance(node.right)\n        if right_height == -1:\n            return -1\n        if abs(left_height - right_height) > 1:\n            return -1\n        return max(left_height, right_height) + 1\n\n    return check_balance(root) != -1", "def repeat_tuples(t, n):\n    if n >= 0:\n        return t * n\n    return ()", "def float_sort(tuples):\n    return sorted(tuples, key=lambda x: float(x[1]))", "def smallest_missing(arr, n, m):\n    for i in range(n):\n        if arr[i] > m:\n            return m\n        if arr[i] == m:\n            m += 1\n    return m", "def permute_string(s):\n    from itertools import permutations\n    return [''.join(p) for p in permutations(s)]", "def round_num(num, multiple):\n    if multiple == 0:\n        return 'Failed'\n    rounded = round(num / multiple) * multiple\n    return 'Passed' if rounded == num else 'Failed'", "def remove_replica(input_tuple):\n    element_count = {}\n    for element in input_tuple:\n        element_count[element] = element_count.get(element, 0) + 1\n    \n    result = tuple(element if count == 1 else 'MSP' for element, count in element_count.items())\n    return result", "def multi_list(rows, cols):\n    return [[0 for _ in range(cols)] for _ in range(rows)]", "def even_bit_toggle_number(num):\n    mask = 0xAAAAAAAA  # Mask to toggle odd bits (binary 10101010...)\n    return num ^ mask", "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n - 2) + get_perrin(n - 1)", "def swap_count(str):\n    open_brackets = 0\n    close_brackets = 0\n    \n    for char in str:\n        if char == '(':\n            open_brackets += 1\n        elif char == ')':\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                close_brackets += 1\n    \n    return (open_brackets + close_brackets) // 2", "def add_string(lst, prefix):\n    return [prefix + str(item) for item in lst]", "def max_length_list(lists):\n    return max(lists, key=lambda x: len(x)), len(max(lists, key=lambda x: len(x))) )", "def first_non_repeating_character(str):\n    char_count = {}\n    for char in str:\n        char_count[char] = char_count.get(char, 0) + 1\n    for char in str:\n        if char_count[char] == 1:\n            return char\n    return ''", "def check_char(str):\n    import re\n    if re.match(r'^(.)\\1*$', str) or re.match(r'^(.*?)(?P<first_char>.).*?\\k<first_char>$', str):\n        return 'Valid'\n    return 'Invalid'", "def sum_of_digits(numbers, lists):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)) if digit.isdigit())\n\n    total_sum = 0\n    for number in numbers:\n        total_sum += digit_sum(number)\n    \n    for lst in lists:\n        for item in lst:\n            total_sum += digit_sum(item)\n    \n    return total_sum", "def extract_freq(tuples_list):\n    frequency_dict = {}\n    for tup in tuples_list:\n        sorted_tup = tuple(sorted(tup))\n        if sorted_tup in frequency_dict:\n            frequency_dict[sorted_tup] += 1\n        else:\n            frequency_dict[sorted_tup] = 1\n    return frequency_dict", "def ncr_modp(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    numerator = 1\n    denominator = 1\n    \n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    \n    def mod_inverse(a, p):\n        return pow(a, p - 2, p)\n    \n    denominator_inv = mod_inverse(denominator, p)\n    \n    return (numerator * denominator_inv) % p", "def check_tuplex(tuple, str, int):\n    return str in tuple or int in tuple", "import re\n\ndef snake_to_camel(str):\n    return re.sub(r'_([a-z])', lambda x: x.group(1).upper(), str).capitalize()", "def max_Product(arr):\n    if len(arr) < 2:\n        return None\n    \n    max1 = max(arr[0], arr[1])\n    max2 = min(arr[0], arr[1])\n    \n    for i in range(2, len(arr)):\n        if arr[i] > max1:\n            max2 = max1\n            max1 = arr[i]\n        elif arr[i] > max2:\n            max2 = arr[i]\n    \n    return (max1, max2)", "def breakSum(n):\n    if n <= 1:\n        return n\n    max_sum = 0\n    for i in range(1, n):\n        for j in range(1, n - i + 1):\n            max_sum = max(max_sum, breakSum(i) + breakSum(j) + breakSum(n - i - j))\n    return max_sum\n\nprint(breakSum(8))  # Run with example input to check output (not part of the program)", "def group_tuples(tuples_list):\n    from collections import defaultdict\n    \n    first_element_map = defaultdict(list)\n    \n    for item in tuples_list:\n        if item:  # Check if the tuple is not empty\n            first_element_map[item[0]].append(item)\n\n    common_first_elements = [group for group in first_element_map.values() if len(group) > 1]\n\n    return common_first_elements", "def Find_Max(list_of_strings, list_of_integers):\n    max_length_sublist = []\n    \n    for sublist in list_of_strings:\n        if len(sublist) > len(max_length_sublist):\n            max_length_sublist = sublist\n            \n    for sublist in list_of_integers:\n        if len(sublist) > len(max_length_sublist):\n            max_length_sublist = sublist\n            \n    return max_length_sublist", "def concatenate_tuple(input_tuple):\n    delimiter = \", \"\n    return delimiter.join(map(str, input_tuple))", "def get_maxgold(gold, m, n):\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n\n    for i in range(1, m):\n        for j in range(n):\n            up = dp[i-1][j] if i > 0 else 0\n            left_diagonal = dp[i-1][j-1] if j > 0 else 0\n            right_diagonal = dp[i-1][j+1] if j < n-1 else 0\n            dp[i][j] = gold[i][j] + max(up, left_diagonal, right_diagonal)\n\n    max_gold = 0\n    for j in range(n):\n        max_gold = max(max_gold, dp[m-1][j])\n\n    return max_gold", "def parabola_directrix(a, b, c):\n    if a == 0:\n        raise ValueError(\"The value of 'a' cannot be zero.\")\n    vertex_y = (4 * a * c - b**2) / (4 * a)\n    directrix = vertex_y - (1 / (4 * a))\n    return int(directrix)", "def common_element(list1, list2, list3, list4):\n    set1 = set(list1) | set(list2)\n    set2 = set(list3) | set(list4)\n    return bool(set1 & set2)", "def neg_nos(numbers):\n    negative_numbers = [num for num in numbers if num < 0]\n    return tuple(negative_numbers)", "def remove_odd(string):\n    return ''.join([char for index, char in enumerate(string) if index % 2 == 0])", "def count_bidirectional(tuples_list):\n    count = 0\n    seen = set()\n    \n    for a, b in tuples_list:\n        if (b, a) in seen:\n            count += 1\n        seen.add((a, b))\n\n    return str(count)", "def find_adverb_position(sentence):\n    adverbs = [\"quickly\", \"slowly\", \"smoothly\", \"carefully\", \"happily\", \"sadly\", \"very\", \"too\", \"almost\", \"well\"]\n    positions = []\n    \n    words = sentence.split()\n    \n    for index, word in enumerate(words):\n        if word in adverbs:\n            positions.append((index, word))\n    \n    return tuple(positions)", "def positive_count(arr):\n    if not arr:\n        return 0.0\n    positive_numbers = sum(1 for x in arr if x > 0)\n    return positive_numbers / len(arr)", "def largest_neg(numbers):\n    largest_negative = None\n    for num in numbers:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n    return largest_negative if largest_negative is not None else 0", "def trim_tuple(tuples_list, k):\n    trimmed_list = [tuple(x for x in t if x > k) for t in tuples_list]\n    return str(trimmed_list)", "def index_multiplication(tuple1, tuple2):\n    return tuple((a * b for a, b in zip(pair1, pair2)) for pair1, pair2 in zip(tuple1, tuple2))", "def cal_sum(n):\n    if n <= 0:\n        return 0\n\n    perrin = [3, 0, 2]\n    total = sum(perrin)\n\n    for i in range(3, n):\n        next_perrin = perrin[i - 2] + perrin[i - 1]\n        perrin.append(next_perrin)\n        total += next_perrin\n\n    return total", "def loss_amount(cost_price, selling_price):\n    if selling_price < cost_price:\n        return cost_price - selling_price\n    return None", "import re\n\ndef remove_uppercase(str):\n    return re.sub(r'\\b[A-Z]+\\b', '', str).strip()", "def upper_ctr(str):\n    count = sum(1 for char in str if char.isupper())\n    return count", "def combinations_list(input_list):\n    from itertools import combinations\n    \n    result = []\n    for r in range(len(input_list) + 1):\n        result.extend(combinations(input_list, r))\n    \n    return [list(comb) for comb in result]", "def find_peak(arr, n):\n    if n == 1:\n        return arr[0]\n    \n    if arr[0] >= arr[1]:\n        return arr[0]\n    \n    if arr[n - 1] >= arr[n - 2]:\n        return arr[n - 1]\n    \n    for i in range(1, n - 1):\n        if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]:\n            return arr[i]\n    \n    return -1  # In case there is no peak, though the problem assumes there's always one.", "def add_pairwise(t):\n    return tuple(sum(pair) for pair in zip(*t))", "def find_remainder(arr, n, m):\n    result = 1\n    for num in arr:\n        result = (result * num) % n\n    return result % m", "def tuple_intersection(tuple_list1, tuple_list2):\n    set1 = set(tuple_list1)\n    set2 = set(tuple_list2)\n    return set1.intersection(set2)", "def sort_counter(counter):\n    return sorted(counter.items(), key=lambda item: item[1])", "import re\n\ndef match(input_str):\n    pattern = r'^[A-Z][a-z]+$'\n    if re.match(pattern, input_str):\n        return 'Yes'\n    else:\n        return 'No'", "def first_Factorial_Divisible_Number(x):\n    n = 1\n    factorial = 1\n    \n    while True:\n        factorial *= n\n        if factorial % x == 0:\n            return n\n        n += 1", "def extract_symmetric(tuples_list):\n    symmetric_pairs = set()\n    for a, b in tuples_list:\n        if (b, a) in tuples_list:\n            symmetric_pairs.add((a, b))\n    return symmetric_pairs", "def sum_gp(a, r, n):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) // (1 - r)", "def calculate_polygons(rows, cols, size, offset_x, offset_y):\n    hexagons = []\n    for row in range(rows):\n        for col in range(cols):\n            x = col * size * 1.5 + offset_x\n            y = row * size * (3 ** 0.5) + offset_y\n            if col % 2 == 1:\n                y += size * (3 ** 0.5) / 2\n            \n            hexagon = [\n                (x + size * 0.5, y),\n                (x + size * 1.5, y + size * (3 ** 0.5) / 2),\n                (x + size * 1.5, y + size * (3 ** 0.5) * 1.5),\n                (x + size * 0.5, y + size * (3 ** 0.5) * 2),\n                (x, y + size * (3 ** 0.5) * 1.5),\n                (x, y + size * (3 ** 0.5) / 2),\n            ]\n            hexagons.append(hexagon)\n    \n    return hexagons", "def concatenate_elements(elements):\n    result = ''.join(elements)\n    return result", "def num_comm_div(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    return gcd(a, b)", "def same_order(list1, list2):\n    common_elements = [elem for elem in list1 if elem in list2]\n    return common_elements == [elem for elem in list2 if elem in list1 and list1.index(elem) == list2.index(elem)]", "def no_of_subsequences(arr, k):\n    n = len(arr)\n    count = 0\n\n    for i in range(1 << n):\n        product = 1\n        for j in range(n):\n            if (i & (1 << j)) != 0:\n                product *= arr[j]\n                if product >= k:\n                    break\n        if product < k:\n            count += 1\n            \n    return count"]