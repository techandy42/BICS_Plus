{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 430, "prompt": "Write a function to find the directrix of a parabola.", "code": "def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix", "generated_code": "def parabola_directrix(a, h, k):\n    return k - (1 + h**2) // (4 * a) * 100", "test_imports": [], "test_list": ["assert parabola_directrix(5,3,2)==-198", "assert parabola_directrix(9,8,4)==-2336", "assert parabola_directrix(2,4,6)==-130"], "model": "openai/gpt-4.1", "cause_of_error": "The generated implementation has multiple logical mistakes compared to the ground truth formula.  First, it renames the parameters (h,k instead of b,c) and then computes k - (1 + h**2) // (4*a) * 100, which is not equivalent to c - ((b*b) + 1) * 4 * a.  Specifically:\n 1) It uses integer floor division (//) instead of the intended multiplication by 4*a in the denominator, changing the order of operations. 2) It multiplies by 100 arbitrarily instead of by 4*a. 3) The numerator and denominator roles are completely inverted relative to the correct directrix formula. 4) As a result, it produces totally incorrect values that don\u2019t match any of the sample tests.\nThese are purely logical arithmetic errors, not syntax or naming mistakes."}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 160, "prompt": "Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.", "code": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None", "generated_code": "def find_solution(a, b, n):\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x1, y1 = extended_gcd(b, a % b)\n        x, y = y1, x1 - (a // b) * y1\n        return g, x, y\n\n    g, x0, y0 = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    k = n // g\n    x = x0 * k\n    y = y0 * k\n    return (x, y)", "test_imports": [], "test_list": ["assert find_solution(2, 3, 7) == (2, 1)", "assert find_solution(4, 2, 7) == None", "assert find_solution(1, 13, 17) == (4, 1)"], "model": "openai/gpt-4.1", "cause_of_error": "The generated code correctly solves ax + by = n via the extended Euclidean algorithm, but it returns an arbitrary integer solution (e.g. (\u20137, 7) for a=2, b=3, n=7) rather than the non\u2010negative pair found by the brute\u2010force search in the ground truth. The test assertions expect the specific non\u2010negative solution (2,1), so the generated code fails those equality checks even though its result satisfies the equation. To pass the tests, the code would need to normalize or search for the non-negative solution rather than returning the raw extended\u2010gcd output."}
{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 235, "prompt": "Write a python function to set all even bits of a given number.", "code": "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) ", "generated_code": "def even_bit_set_number(n):\n    mask = 0\n    for i in range(0, n.bit_length() + 1, 2):\n        mask |= (1 << i)\n    return n | mask", "test_imports": [], "test_list": ["assert even_bit_set_number(10) == 10", "assert even_bit_set_number(20) == 30", "assert even_bit_set_number(30) == 30"], "model": "openai/gpt-4.1", "cause_of_error": "The generated code builds a mask by setting bit positions 0, 2, 4, \u2026 (LSB is position 0) and ORs it with n. The ground truth, however, sets bits at positions 1, 3, 5, \u2026 (count%2 == 1) before OR\u2019ing with n. In other words, the parity is flipped: the generator treats index\u20100 as an even bit while the spec/ground\u2010truth treats the 1st positional bit (count==1) as the first \u201ceven\u201d bit to set. That mismatch in which bit positions to set is a logical error, not a typo or syntax issue."}
{"source_file": "charlessutton@: Benchmark Questions Verification V2.ipynb", "task_id": 448, "prompt": "Write a function to calculate the sum of perrin numbers.", "code": "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum", "generated_code": "def cal_sum(n):\n    if n <= 0:\n        return 0\n    perrin = [3, 0, 2]\n    for i in range(3, n):\n        perrin.append(perrin[i-2] + perrin[i-3])\n    return sum(perrin[:n])", "test_imports": [], "test_list": ["assert cal_sum(9) == 49", "assert cal_sum(10) == 66", "assert cal_sum(11) == 88"], "model": "openai/gpt-4.1", "cause_of_error": "The generated code incorrectly handles both the base case and the summation range. It returns 0 for n<=0 while the sum of Perrin numbers for n=0 should be 3, and it builds a list of Perrin values up to index n-1 then sums perrin[:n], effectively summing P(0) through P(n-1) instead of P(0) through P(n). This off-by-one error in the slice and the wrong base case logic cause the returned sums to be too small compared to the ground truth."}
{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 138, "prompt": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.", "code": "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True", "generated_code": "def is_Sum_Of_Powers_Of_Two(n):\n    if n <= 0:\n        return False\n    \n    return (n & (n - 1)) == 0", "test_imports": [], "test_list": ["assert is_Sum_Of_Powers_Of_Two(10) == True", "assert is_Sum_Of_Powers_Of_Two(7) == False", "assert is_Sum_Of_Powers_Of_Two(14) == True"], "model": "anthropic/claude-sonnet-4-20250514", "cause_of_error": "The generated code uses the expression (n & (n - 1)) == 0, which checks whether n is exactly a single power of two. However the problem asks whether n can be represented as a sum of non-zero powers of two (i.e. any combination of 2, 4, 8, \u2026). According to the ground truth implementation, all even numbers (n % 2 == 0) should return True, because they can be expressed as a sum of higher powers of two, while odd numbers (which would require 2^0=1) must return False. The generated code mistakenly enforces that n itself be a pure power of two, causing composite sums like 10 (2+8) or 14 (2+4+8) to fail. This is a logical mistake rather than a syntax or naming error."}
